// Code generated by ormgen; DO NOT EDIT.
package query

import (
	"context"
	"database/sql"
	"time"

	"github.com/mickamy/ormgen/example/model"
	"github.com/mickamy/ormgen/orm"
	"github.com/mickamy/ormgen/scope"
)

// Users returns a new Query for the users table.
func Users(db orm.Querier) *orm.Query[model.User] {
	q := orm.NewQuery[model.User](
		db, orm.ResolveTableName[model.User]("users"), usersColumns, "id",
		scanUser, userColumnValuePairs, setUserPK,
	)
	q.RegisterJoin("Posts", orm.JoinConfig{
		TargetTable: orm.ResolveTableName[model.Post]("posts"), TargetColumn: "user_id",
		SourceTable: orm.ResolveTableName[model.User]("users"), SourceColumn: "id",
	})
	q.RegisterPreloader("Posts", preloadUserPosts)
	q.RegisterJoin("Profile", orm.JoinConfig{
		TargetTable: orm.ResolveTableName[model.Profile]("profiles"), TargetColumn: "user_id",
		SourceTable: orm.ResolveTableName[model.User]("users"), SourceColumn: "id",
		SelectColumns: []string{"id", "user_id", "bio"},
	})
	q.RegisterPreloader("Profile", preloadUserProfile)
	q.RegisterPreloader("Tags", preloadUserTags)
	q.RegisterTimestamps(
		[]string{"created_at"},
		setUserCreatedAt,
		nil,
		nil,
	)
	return q
}

var usersColumns = []string{"id", "name", "email", "created_at"}

func scanUser(rows *sql.Rows) (model.User, error) {
	cols, _ := rows.Columns()
	var v model.User
	var joinScanProfilePK sql.NullInt64
	var joinScanProfile model.Profile
	dest := make([]any, len(cols))
	for i, col := range cols {
		switch col {
		case "id":
			dest[i] = &v.ID
		case "name":
			dest[i] = &v.Name
		case "email":
			dest[i] = &v.Email
		case "created_at":
			dest[i] = &v.CreatedAt
		case "Profile__id":
			dest[i] = &joinScanProfilePK
		case "Profile__user_id":
			dest[i] = &joinScanProfile.UserID
		case "Profile__bio":
			dest[i] = &joinScanProfile.Bio
		default:
			dest[i] = new(any)
		}
	}
	err := rows.Scan(dest...)
	if joinScanProfilePK.Valid {
		joinScanProfile.ID = int(joinScanProfilePK.Int64)
		v.Profile = &joinScanProfile
	}
	return v, err
}

func userColumnValuePairs(v *model.User, includesPK bool) ([]string, []any) {
	if includesPK {
		return []string{"id", "name", "email", "created_at"},
			[]any{v.ID, v.Name, v.Email, v.CreatedAt}
	}
	return []string{"name", "email", "created_at"},
		[]any{v.Name, v.Email, v.CreatedAt}
}

func setUserPK(v *model.User, id int64) {
	v.ID = int(id)
}

func setUserCreatedAt(v *model.User, now time.Time) {
	if v.CreatedAt.IsZero() {
		v.CreatedAt = now
	}
}
func preloadUserPosts(ctx context.Context, db orm.Querier, results []model.User) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]int, len(results))
	for i := range results {
		ids[i] = results[i].ID
	}
	related, err := Posts(db).Scopes(scope.In("user_id", ids)).All(ctx)
	if err != nil {
		return err
	}
	byFK := make(map[int][]model.Post)
	for _, r := range related {
		byFK[r.UserID] = append(byFK[r.UserID], r)
	}
	for i := range results {
		results[i].Posts = byFK[results[i].ID]
	}
	return nil
}
func preloadUserProfile(ctx context.Context, db orm.Querier, results []model.User) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]int, len(results))
	for i := range results {
		ids[i] = results[i].ID
	}
	related, err := Profiles(db).Scopes(scope.In("user_id", ids)).All(ctx)
	if err != nil {
		return err
	}
	byFK := make(map[int]*model.Profile)
	for i := range related {
		byFK[related[i].UserID] = &related[i]
	}
	for i := range results {
		results[i].Profile = byFK[results[i].ID]
	}
	return nil
}
func preloadUserTags(ctx context.Context, db orm.Querier, results []model.User) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]int, len(results))
	for i := range results {
		ids[i] = results[i].ID
	}
	pairs, err := orm.QueryJoinTable[int, int]( //nolint:lll
		ctx, db, "user_tags", "user_id", "tag_id", ids,
	)
	if err != nil {
		return err
	}
	targetIDs := orm.UniqueTargets(pairs)
	related, err := Tags(db).Scopes(scope.In("id", targetIDs)).All(ctx)
	if err != nil {
		return err
	}
	byPK := make(map[int]model.Tag)
	for _, r := range related {
		byPK[r.ID] = r
	}
	grouped := orm.GroupBySource(pairs)
	for i := range results {
		tIDs := grouped[results[i].ID]
		items := make([]model.Tag, 0, len(tIDs))
		for _, tid := range tIDs {
			if v, ok := byPK[tid]; ok {
				items = append(items, v)
			}
		}
		results[i].Tags = items
	}
	return nil
}
