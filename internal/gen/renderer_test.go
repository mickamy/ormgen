package gen_test

import (
	"go/parser"
	"go/token"
	"strings"
	"testing"

	"github.com/mickamy/ormgen/internal/gen"
)

func findStruct(t *testing.T, infos []*gen.StructInfo, name string) *gen.StructInfo {
	t.Helper()
	for _, info := range infos {
		if info.Name == name {
			return info
		}
	}
	t.Fatalf("struct %q not found", name)
	return nil
}

func TestRenderUser(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	info := findStruct(t, infos, "User")
	info.TableName = "users"

	src, err := gen.Render(info)
	if err != nil {
		t.Fatalf("Render: %v", err)
	}

	code := string(src)

	// Verify it's valid Go
	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "user_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	// Check key patterns
	checks := []string{
		"// Code generated by ormgen; DO NOT EDIT.",
		"package testdata",
		"func Users(db orm.Querier) *orm.Query[User]",
		`"users"`,
		"usersColumns",
		"scanUser",
		"userColumnValuePairs",
		"setUserPK",
		`case "id":`,
		`case "name":`,
		`case "created_at":`,
		"dest[i] = &v.ID",
		"dest[i] = &v.CreatedAt",
		"v.ID = int(id)",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderPost(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	info := findStruct(t, infos, "Post")
	info.TableName = "posts"

	src, err := gen.Render(info)
	if err != nil {
		t.Fatalf("Render: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "post_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		"func Posts(db orm.Querier) *orm.Query[Post]",
		"postsColumns",
		"scanPost",
		"postColumnValuePairs",
		"setPostPK",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderNoPK(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("no_pk.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	infos[0].TableName = "no_pks"

	_, err = gen.Render(infos[0])
	if err == nil {
		t.Fatal("expected error for no primary key, got nil")
	}
}

func TestRenderFileMultipleStructs(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	findStruct(t, infos, "User").TableName = "users"
	findStruct(t, infos, "Post").TableName = "posts"

	src, err := gen.RenderFile(infos, gen.RenderOption{})
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	// Verify it's valid Go
	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "model_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	// Both structs should be present in a single file
	checks := []string{
		"func Users(db orm.Querier) *orm.Query[User]",
		"func Posts(db orm.Querier) *orm.Query[Post]",
		"scanUser",
		"scanPost",
		"usersColumns",
		"postsColumns",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderRelations(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("relations.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	findStruct(t, infos, "Author").TableName = "authors"
	findStruct(t, infos, "Article").TableName = "articles"
	findStruct(t, infos, "Profile").TableName = "profiles"

	src, err := gen.RenderFile(infos, gen.RenderOption{})
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "relations_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		// has_many preloader
		"func preloadAuthorArticles(ctx context.Context, db orm.Querier, results []Author)",
		`scope.In("author_id", ids)`,
		"Articles(db)",
		// belongs_to preloader
		"func preloadArticleAuthor(ctx context.Context, db orm.Querier, results []Article)",
		`scope.In("id", ids)`,
		"Authors(db)",
		// has_one preloader
		"func preloadAuthorProfile(ctx context.Context, db orm.Querier, results []Author)",
		// RegisterJoin
		`q.RegisterJoin("Articles"`,
		`q.RegisterJoin("Profile"`,
		`q.RegisterJoin("Author"`,
		// RegisterPreloader
		`q.RegisterPreloader("Articles", preloadAuthorArticles)`,
		`q.RegisterPreloader("Profile", preloadAuthorProfile)`,
		`q.RegisterPreloader("Author", preloadArticleAuthor)`,
		// Imports
		`"context"`,
		`"github.com/mickamy/ormgen/scope"`,
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderFileCrossPackage(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	info := findStruct(t, infos, "User")
	info.TableName = "users"

	opt := gen.RenderOption{
		DestPkg:      "repo",
		SourceImport: "github.com/example/model",
	}

	src, err := gen.RenderFile([]*gen.StructInfo{info}, opt)
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "model_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		"package repo",
		`"github.com/example/model"`,
		"func Users(db orm.Querier) *orm.Query[model.User]",
		"var v model.User",
		"func scanUser(rows *sql.Rows) (model.User, error)",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}
