package gen_test

import (
	"go/parser"
	"go/token"
	"strings"
	"testing"

	"github.com/mickamy/ormgen/internal/gen"
)

func findStruct(t *testing.T, infos []*gen.StructInfo, name string) *gen.StructInfo {
	t.Helper()
	for _, info := range infos {
		if info.Name == name {
			return info
		}
	}
	t.Fatalf("struct %q not found", name)
	return nil
}

func TestRenderUser(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	info := findStruct(t, infos, "User")
	info.TableName = "users"

	src, err := gen.Render(info)
	if err != nil {
		t.Fatalf("Render: %v", err)
	}

	code := string(src)

	// Verify it's valid Go
	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "user_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	// Check key patterns
	checks := []string{
		"// Code generated by ormgen; DO NOT EDIT.",
		"package testdata",
		"func Users(db orm.Querier) *orm.Query[User]",
		`orm.ResolveTableName[User]("users")`,
		"usersColumns",
		"scanUser",
		"userColumnValuePairs",
		"setUserPK",
		`case "id":`,
		`case "name":`,
		`case "created_at":`,
		"dest[i] = &v.ID",
		"dest[i] = &v.CreatedAt",
		"v.ID = int(id)",
		// User has CreatedAt and UpdatedAt by convention
		"setUserCreatedAt",
		"setUserUpdatedAt",
		"q.RegisterTimestamps(",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderPost(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	info := findStruct(t, infos, "Post")
	info.TableName = "posts"

	src, err := gen.Render(info)
	if err != nil {
		t.Fatalf("Render: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "post_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		"func Posts(db orm.Querier) *orm.Query[Post]",
		"postsColumns",
		"scanPost",
		"postColumnValuePairs",
		"setPostPK",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderNoPK(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("no_pk.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	infos[0].TableName = "no_pks"

	_, err = gen.Render(infos[0])
	if err == nil {
		t.Fatal("expected error for no primary key, got nil")
	}
}

func TestRenderFileMultipleStructs(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	findStruct(t, infos, "User").TableName = "users"
	findStruct(t, infos, "Post").TableName = "posts"

	src, err := gen.RenderFile(infos, gen.RenderOption{})
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	// Verify it's valid Go
	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "model_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	// Both structs should be present in a single file
	checks := []string{
		"func Users(db orm.Querier) *orm.Query[User]",
		"func Posts(db orm.Querier) *orm.Query[Post]",
		"scanUser",
		"scanPost",
		"usersColumns",
		"postsColumns",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderRelations(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("relations.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	findStruct(t, infos, "Author").TableName = "authors"
	findStruct(t, infos, "Article").TableName = "articles"
	findStruct(t, infos, "Profile").TableName = "profiles"
	findStruct(t, infos, "Tag").TableName = "tags"
	findStruct(t, infos, "Comment").TableName = "comments"
	findStruct(t, infos, "QRImage").TableName = "qr_images"

	src, err := gen.RenderFile(infos, gen.RenderOption{})
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "relations_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		// has_many preloader
		"func preloadAuthorArticles(ctx context.Context, db orm.Querier, results []Author)",
		`scope.In("author_id", ids)`,
		"Articles(db)",
		// belongs_to preloader
		"func preloadArticleAuthor(ctx context.Context, db orm.Querier, results []Article)",
		`scope.In("id", ids)`,
		"Authors(db)",
		// has_one preloader
		"func preloadAuthorProfile(ctx context.Context, db orm.Querier, results []Author)",
		// RegisterJoin with ResolveTableName
		`q.RegisterJoin("Articles"`,
		`q.RegisterJoin("Profile"`,
		`q.RegisterJoin("Author"`,
		`orm.ResolveTableName[Author]("authors")`,
		`orm.ResolveTableName[Article]("articles")`,
		`orm.ResolveTableName[Profile]("profiles")`,
		// RegisterPreloader
		`q.RegisterPreloader("Articles", preloadAuthorArticles)`,
		`q.RegisterPreloader("Profile", preloadAuthorProfile)`,
		`q.RegisterPreloader("Author", preloadArticleAuthor)`,
		`q.RegisterPreloader("Tags", preloadAuthorTags)`,
		// many_to_many preloader
		"func preloadAuthorTags(ctx context.Context, db orm.Querier, results []Author)",
		`orm.QueryJoinTable[int, int](`,
		`ctx, db, "author_tags", "author_id", "tag_id", ids,`,
		"orm.UniqueTargets(pairs)",
		"orm.GroupBySource(pairs)",
		`scope.In("id", targetIDs)`,
		"Tags(db)",
		// No RegisterJoin for many_to_many
		// Non-pointer belongs_to: value-type map (no pointer)
		"byPK := make(map[int]Author)",
		// Imports
		`"context"`,
		`"github.com/mickamy/ormgen/scope"`,
		// Nullable FK belongs_to (Comment.Author with *string FK)
		"func preloadCommentAuthor(ctx context.Context, db orm.Querier, results []Comment)",
		// Should dereference pointer FK
		"if results[i].AuthorID != nil {",
		"ids = append(ids, *results[i].AuthorID)",
		// Map key should be string, not *string
		"byPK := make(map[string]*Author)",
		// Assignment should check nil
		"results[i].Author = byPK[*results[i].AuthorID]",
	}
	// many_to_many should NOT generate RegisterJoin
	negativeChecks := []string{
		`q.RegisterJoin("Tags"`,
		// Non-pointer belongs_to should NOT use pointer map
		"map[int]*Author",
		// Nullable FK should NOT use pointer as map key
		"map[*string]",
		// QRImage FK field should NOT be resolved via SnakeToCamel (which would give "AuthorId")
		"results[i].AuthorId",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
	for _, unwanted := range negativeChecks {
		if strings.Contains(code, unwanted) {
			t.Errorf("unexpected %q in generated code:\n%s", unwanted, code)
		}
	}
}

func TestRenderTimestamps(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("timestamps.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	// Test all three timestamp structs
	findStruct(t, infos, "WithTimestamps").TableName = "with_timestamps"
	findStruct(t, infos, "WithCustomTimestampCols").TableName = "with_custom_timestamp_cols"
	findStruct(t, infos, "WithTagAndConvention").TableName = "with_tag_and_conventions"

	src, err := gen.RenderFile(infos, gen.RenderOption{})
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "timestamps_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		// time import
		`"time"`,
		// Convention-based: RegisterTimestamps call
		`q.RegisterTimestamps(`,
		// Convention-based: setter functions
		"func setWithTimestampsCreatedAt(v *WithTimestamps, now time.Time)",
		"func setWithTimestampsUpdatedAt(v *WithTimestamps, now time.Time)",
		// Zero check for createdAt
		"if v.CreatedAt.IsZero()",
		// updatedAt always sets
		"v.UpdatedAt = now",
		// Custom tag: setter functions
		"func setWithCustomTimestampColsCreatedAt(v *WithCustomTimestampCols, now time.Time)",
		"func setWithCustomTimestampColsUpdatedAt(v *WithCustomTimestampCols, now time.Time)",
		// createdAt column list
		`"created_at"`,
		`"inserted_at"`,
		// updatedAt column list (new: updatedAtCols passed to RegisterTimestamps)
		`"updated_at"`,
		`"modified_at"`,
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderFileCrossPackage(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("user.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	info := findStruct(t, infos, "User")
	info.TableName = "users"

	opt := gen.RenderOption{
		DestPkg:      "repo",
		SourceImport: "github.com/example/model",
	}

	src, err := gen.RenderFile([]*gen.StructInfo{info}, opt)
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "model_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		"package repo",
		`"github.com/example/model"`,
		"func Users(db orm.Querier) *orm.Query[model.User]",
		"var v model.User",
		"func scanUser(rows *sql.Rows) (model.User, error)",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
}

func TestRenderJoinScan(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("relations.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	findStruct(t, infos, "Author").TableName = "authors"
	findStruct(t, infos, "Article").TableName = "articles"
	findStruct(t, infos, "Profile").TableName = "profiles"
	findStruct(t, infos, "Tag").TableName = "tags"
	findStruct(t, infos, "Comment").TableName = "comments"
	findStruct(t, infos, "QRImage").TableName = "qr_images"

	src, err := gen.RenderFile(infos, gen.RenderOption{})
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	checks := []string{
		// belongs_to (non-pointer): Article.Author — scan directly into v.Author.Field
		`case "Author__id":`,
		`dest[i] = &v.Author.ID`,
		`case "Author__name":`,
		`dest[i] = &v.Author.Name`,
		// SelectColumns in RegisterJoin for belongs_to
		`SelectColumns: []string{"id", "name"},`,
		// has_one (pointer): Author.Profile — uses NullInt64 + temp struct
		`var joinScanProfilePK sql.NullInt64`,
		`var joinScanProfile Profile`,
		`case "Profile__id":`,
		`dest[i] = &joinScanProfilePK`,
		`case "Profile__bio":`,
		`dest[i] = &joinScanProfile.Bio`,
		`if joinScanProfilePK.Valid {`,
		`joinScanProfile.ID = int(joinScanProfilePK.Int64)`,
		`v.Profile = &joinScanProfile`,
		// SelectColumns in RegisterJoin for has_one
		`SelectColumns: []string{"id", "author_id", "bio"},`,
	}

	negativeChecks := []string{
		// has_many (Articles) should NOT have SelectColumns
		// Check that Articles RegisterJoin doesn't have SelectColumns by
		// looking for a pattern that would only appear if has_many got SelectColumns.
		`SelectColumns: []string{"id", "author_id", "title"},`,
		// many_to_many (Tags) should NOT have join scan
		`joinScanTag`,
	}

	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}
	for _, unwanted := range negativeChecks {
		if strings.Contains(code, unwanted) {
			t.Errorf("unexpected %q in generated code:\n%s", unwanted, code)
		}
	}
}

func TestRenderCrossPackageRelations(t *testing.T) {
	t.Parallel()

	infos, err := gen.Parse(testdataPath("cross_pkg_relations.go"))
	if err != nil {
		t.Fatalf("Parse: %v", err)
	}

	findStruct(t, infos, "EndUser").TableName = "end_users"
	findStruct(t, infos, "UserEmail").TableName = "user_emails"

	opt := gen.RenderOption{
		DestPkg:      "query",
		SourceImport: "github.com/example/user/model",
	}

	src, err := gen.RenderFile(infos, opt)
	if err != nil {
		t.Fatalf("RenderFile: %v", err)
	}

	code := string(src)

	// Verify it's valid Go
	fset := token.NewFileSet()
	if _, err := parser.ParseFile(fset, "cross_pkg_gen.go", src, 0); err != nil {
		t.Fatalf("generated code does not parse: %v\n%s", err, code)
	}

	checks := []string{
		// External model import with alias (auth/model conflicts with user/model)
		`authmodel "github.com/example/auth/model"`,
		// External query import with alias (auth/query conflicts with user/query)
		`authquery "github.com/example/auth/query"`,
		// Cross-package type uses resolved alias
		"authmodel.OAuthAccount",
		// Cross-package factory uses external query package
		"authquery.OAuthAccounts(db)",
		// Same-package type uses source import prefix
		"model.UserEmail",
		// Same-package factory is local (no prefix)
		"UserEmails(db)",
		// Source import is present
		`"github.com/example/user/model"`,
		// Non-pointer has_one: value-type map (no pointer)
		"byFK := make(map[int]model.UserEmail)",
	}
	for _, want := range checks {
		if !strings.Contains(code, want) {
			t.Errorf("missing %q in generated code:\n%s", want, code)
		}
	}

	// Non-pointer has_one should NOT use pointer map
	if strings.Contains(code, "map[int]*model.UserEmail") {
		t.Errorf("unexpected pointer map for non-pointer has_one in generated code:\n%s", code)
	}

	// Bare "model.OAuthAccount" (without "auth" prefix) should NOT appear.
	stripped := strings.ReplaceAll(code, "authmodel.OAuthAccount", "")
	if strings.Contains(stripped, "model.OAuthAccount") {
		t.Errorf("unexpected bare %q in generated code:\n%s", "model.OAuthAccount", code)
	}

	// Bare "OAuthAccounts(db)" (without "authquery." prefix) should NOT appear.
	stripped2 := strings.ReplaceAll(code, "authquery.OAuthAccounts(db)", "")
	if strings.Contains(stripped2, "OAuthAccounts(db)") {
		t.Errorf("unexpected bare %q in generated code:\n%s", "OAuthAccounts(db)", code)
	}
}
