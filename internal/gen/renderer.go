package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"strings"
	"text/template"
	"unicode"
)

// RenderOption controls the output of RenderFile.
type RenderOption struct {
	DestPkg      string // output package name (empty = same as source)
	SourceImport string // import path for source package (required when DestPkg is set)
}

// Render generates the Go source code for a single StructInfo.
// The returned bytes are formatted by gofmt.
func Render(info *StructInfo) ([]byte, error) {
	return RenderFile([]*StructInfo{info}, RenderOption{})
}

// RenderFile generates a single Go source file for all given StructInfos.
// The returned bytes are formatted by gofmt.
func RenderFile(infos []*StructInfo, opt RenderOption) ([]byte, error) {
	if len(infos) == 0 {
		return nil, errors.New("no structs to render")
	}

	pkg := opt.DestPkg
	if pkg == "" {
		pkg = infos[0].Package
	}

	typePrefix := ""
	if opt.SourceImport != "" {
		// e.g. "github.com/example/model" â†’ "model."
		parts := strings.Split(opt.SourceImport, "/")
		typePrefix = parts[len(parts)-1] + "."
	}

	structs := make([]templateData, 0, len(infos))
	for _, info := range infos {
		pk, err := info.PrimaryKeyField()
		if err != nil {
			return nil, err
		}

		data := templateData{
			TypeName:    typePrefix + info.Name,
			TableName:   info.TableName,
			FactoryName: exportedName(info.TableName),
			PK:          pk,
			Fields:      info.Fields,
			ScanFunc:    unexportedName("scan" + info.Name),
			ColValFunc:  unexportedName(info.Name + "ColumnValuePairs"),
			SetPKFunc:   unexportedName("set" + info.Name + "PK"),
			ColumnsVar:  unexportedName(info.TableName + "Columns"),
			IsIntPK:     isIntType(pk.GoType),
		}
		structs = append(structs, data)
	}

	fileData := fileTemplateData{
		Package:      pkg,
		SourceImport: opt.SourceImport,
		Structs:      structs,
	}

	var buf bytes.Buffer
	if err := fileTmpl.Execute(&buf, fileData); err != nil {
		return nil, fmt.Errorf("execute template: %w", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("gofmt: %w", err)
	}
	return src, nil
}

type fileTemplateData struct {
	Package      string
	SourceImport string
	Structs      []templateData
}

type templateData struct {
	TypeName    string
	TableName   string
	FactoryName string
	PK          *FieldInfo
	Fields      []FieldInfo
	ScanFunc    string
	ColValFunc  string
	SetPKFunc   string
	ColumnsVar  string
	IsIntPK     bool
}

func (d templateData) NonPKFields() []FieldInfo {
	var fields []FieldInfo
	for _, f := range d.Fields {
		if !f.PrimaryKey {
			fields = append(fields, f)
		}
	}
	return fields
}

var funcMap = template.FuncMap{
	"join": strings.Join,
	"quote": func(s string) string {
		return `"` + s + `"`
	},
}

var fileTmpl = template.Must(template.New("gen").Funcs(funcMap).Parse(fileTemplate))

const fileTemplate = `// Code generated by ormgen; DO NOT EDIT.
package {{.Package}}

import (
	"database/sql"

	"github.com/mickamy/ormgen/orm"
	{{- if .SourceImport}}
	"{{.SourceImport}}"
	{{- end}}
)
{{range .Structs}}
// {{.FactoryName}} returns a new Query for the {{.TableName}} table.
func {{.FactoryName}}(db orm.Querier) *orm.Query[{{.TypeName}}] {
	return orm.NewQuery[{{.TypeName}}](
		db, "{{.TableName}}", {{.ColumnsVar}}, "{{.PK.Column}}",
		{{.ScanFunc}}, {{.ColValFunc}}, {{if .IsIntPK}}{{.SetPKFunc}}{{else}}nil{{end}},
	)
}

var {{.ColumnsVar}} = []string{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} }

func {{.ScanFunc}}(rows *sql.Rows) ({{.TypeName}}, error) {
	cols, _ := rows.Columns()
	var v {{.TypeName}}
	dest := make([]any, len(cols))
	for i, col := range cols {
		switch col {
		{{- range .Fields}}
		case {{quote .Column}}:
			dest[i] = &v.{{.Name}}
		{{- end}}
		default:
			dest[i] = new(any)
		}
	}
	err := rows.Scan(dest...)
	return v, err
}

func {{.ColValFunc}}(v *{{.TypeName}}, includesPK bool) ([]string, []any) {
	if includesPK {
		return []string{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} },
			[]any{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}v.{{$f.Name}}{{end -}} }
	}
	return []string{ {{- range $i, $f := .NonPKFields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} },
		[]any{ {{- range $i, $f := .NonPKFields}}{{if $i}}, {{end}}v.{{$f.Name}}{{end -}} }
}
{{if .IsIntPK}}
func {{.SetPKFunc}}(v *{{.TypeName}}, id int64) {
	v.{{.PK.Name}} = {{.PK.GoType}}(id)
}
{{end}}{{end}}`

func exportedName(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func unexportedName(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func isIntType(goType string) bool {
	switch goType {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return true
	default:
		return false
	}
}
