package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"strings"
	"text/template"
	"unicode"

	"github.com/jinzhu/inflection"

	"github.com/mickamy/ormgen/internal/naming"
)

// RenderOption controls the output of RenderFile.
type RenderOption struct {
	DestPkg      string // output package name (empty = same as source)
	SourceImport string // import path for source package (required when DestPkg is set)
}

// Render generates the Go source code for a single StructInfo.
// The returned bytes are formatted by gofmt.
func Render(info *StructInfo) ([]byte, error) {
	return RenderFile([]*StructInfo{info}, RenderOption{})
}

// RenderFile generates a single Go source file for all given StructInfos.
// The returned bytes are formatted by gofmt.
func RenderFile(infos []*StructInfo, opt RenderOption) ([]byte, error) {
	if len(infos) == 0 {
		return nil, errors.New("no structs to render")
	}

	pkg := opt.DestPkg
	if pkg == "" {
		pkg = infos[0].Package
	}

	typePrefix := ""
	if opt.SourceImport != "" {
		// e.g. "github.com/example/model" â†’ "model."
		parts := strings.Split(opt.SourceImport, "/")
		typePrefix = parts[len(parts)-1] + "."
	}

	structs := make([]templateData, 0, len(infos))
	for _, info := range infos {
		pk, err := info.PrimaryKeyField()
		if err != nil {
			return nil, err
		}

		data := templateData{
			TypeName:    typePrefix + info.Name,
			TableName:   info.TableName,
			FactoryName: naming.SnakeToCamel(info.TableName),
			PK:          pk,
			Fields:      info.Fields,
			ScanFunc:    unexportedName("scan" + info.Name),
			ColValFunc:  unexportedName(info.Name + "ColumnValuePairs"),
			SetPKFunc:   unexportedName("set" + info.Name + "PK"),
			ColumnsVar:  unexportedName(naming.SnakeToCamel(info.TableName) + "Columns"),
			IsIntPK:     isIntType(pk.GoType),
			Relations:   buildRelationData(info, pk, typePrefix),
		}
		structs = append(structs, data)
	}

	hasRelations := false
	for _, s := range structs {
		if len(s.Relations) > 0 {
			hasRelations = true
			break
		}
	}

	fileData := fileTemplateData{
		Package:      pkg,
		SourceImport: opt.SourceImport,
		HasRelations: hasRelations,
		Structs:      structs,
	}

	var buf bytes.Buffer
	if err := fileTmpl.Execute(&buf, fileData); err != nil {
		return nil, fmt.Errorf("execute template: %w", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("gofmt: %w", err)
	}
	return src, nil
}

type fileTemplateData struct {
	Package      string
	SourceImport string
	HasRelations bool
	Structs      []templateData
}

type templateData struct {
	TypeName    string
	TableName   string
	FactoryName string
	PK          *FieldInfo
	Fields      []FieldInfo
	ScanFunc    string
	ColValFunc  string
	SetPKFunc   string
	ColumnsVar  string
	IsIntPK     bool
	Relations   []relationTemplateData
}

type relationTemplateData struct {
	FieldName        string // "Posts"
	ParentType       string // "model.User" or "User" (parent struct type)
	TargetType       string // "model.Post" or "Post"
	TargetFactory    string // "Posts"
	ForeignKey       string // "user_id"
	ForeignKeyField  string // "UserID"
	RelType          string // "has_many", "belongs_to", "has_one", or "many_to_many"
	PreloaderName    string // "preloadUserPosts"
	KeyType          string // Go type for map key ("int")
	ParentPKField    string // "ID"
	JoinTargetTable  string
	JoinTargetColumn string
	JoinSourceTable  string
	JoinSourceColumn string
	JoinTable        string // many_to_many only: "user_tags"
	References       string // many_to_many only: "tag_id"
	TargetTable      string // many_to_many only: target table name "tags"
	TargetPKColumn   string // many_to_many only: target PK column "id"
}

func (d templateData) NonPKFields() []FieldInfo {
	var fields []FieldInfo
	for _, f := range d.Fields {
		if !f.PrimaryKey {
			fields = append(fields, f)
		}
	}
	return fields
}

var funcMap = template.FuncMap{
	"join": strings.Join,
	"quote": func(s string) string {
		return `"` + s + `"`
	},
}

var fileTmpl = template.Must(template.New("gen").Funcs(funcMap).Parse(fileTemplate))

const fileTemplate = `// Code generated by ormgen; DO NOT EDIT.
package {{.Package}}

import (
	{{- if .HasRelations}}
	"context"
	{{- end}}
	"database/sql"

	"github.com/mickamy/ormgen/orm"
	{{- if .HasRelations}}
	"github.com/mickamy/ormgen/scope"
	{{- end}}
	{{- if .SourceImport}}
	"{{.SourceImport}}"
	{{- end}}
)
{{range .Structs}}
// {{.FactoryName}} returns a new Query for the {{.TableName}} table.
func {{.FactoryName}}(db orm.Querier) *orm.Query[{{.TypeName}}] {
	{{- if .Relations}}
	q := orm.NewQuery[{{.TypeName}}](
		db, orm.ResolveTableName[{{.TypeName}}]("{{.TableName}}"), {{.ColumnsVar}}, "{{.PK.Column}}",
		{{.ScanFunc}}, {{.ColValFunc}}, {{if .IsIntPK}}{{.SetPKFunc}}{{else}}nil{{end}},
	)
	{{- range .Relations}}
	{{- if ne .RelType "many_to_many"}}
	q.RegisterJoin("{{.FieldName}}", orm.JoinConfig{
		TargetTable: orm.ResolveTableName[{{.TargetType}}]("{{.JoinTargetTable}}"), TargetColumn: "{{.JoinTargetColumn}}",
		SourceTable: orm.ResolveTableName[{{.ParentType}}]("{{.JoinSourceTable}}"), SourceColumn: "{{.JoinSourceColumn}}",
	})
	{{- end}}
	q.RegisterPreloader("{{.FieldName}}", {{.PreloaderName}})
	{{- end}}
	return q
	{{- else}}
	return orm.NewQuery[{{.TypeName}}](
		db, orm.ResolveTableName[{{.TypeName}}]("{{.TableName}}"), {{.ColumnsVar}}, "{{.PK.Column}}",
		{{.ScanFunc}}, {{.ColValFunc}}, {{if .IsIntPK}}{{.SetPKFunc}}{{else}}nil{{end}},
	)
	{{- end}}
}

var {{.ColumnsVar}} = []string{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} }

func {{.ScanFunc}}(rows *sql.Rows) ({{.TypeName}}, error) {
	cols, _ := rows.Columns()
	var v {{.TypeName}}
	dest := make([]any, len(cols))
	for i, col := range cols {
		switch col {
		{{- range .Fields}}
		case {{quote .Column}}:
			dest[i] = &v.{{.Name}}
		{{- end}}
		default:
			dest[i] = new(any)
		}
	}
	err := rows.Scan(dest...)
	return v, err
}

func {{.ColValFunc}}(v *{{.TypeName}}, includesPK bool) ([]string, []any) {
	if includesPK {
		return []string{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} },
			[]any{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}v.{{$f.Name}}{{end -}} }
	}
	return []string{ {{- range $i, $f := .NonPKFields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} },
		[]any{ {{- range $i, $f := .NonPKFields}}{{if $i}}, {{end}}v.{{$f.Name}}{{end -}} }
}
{{if .IsIntPK}}
func {{.SetPKFunc}}(v *{{.TypeName}}, id int64) {
	v.{{.PK.Name}} = {{.PK.GoType}}(id)
}
{{end}}
{{- range .Relations}}
{{- if eq .RelType "has_many"}}
func {{.PreloaderName}}(ctx context.Context, db orm.Querier, results []{{.ParentType}}) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]{{.KeyType}}, len(results))
	for i := range results {
		ids[i] = results[i].{{.ParentPKField}}
	}
	related, err := {{.TargetFactory}}(db).Scopes(scope.In("{{.ForeignKey}}", ids)).All(ctx)
	if err != nil {
		return err
	}
	byFK := make(map[{{.KeyType}}][]{{.TargetType}})
	for _, r := range related {
		byFK[r.{{.ForeignKeyField}}] = append(byFK[r.{{.ForeignKeyField}}], r)
	}
	for i := range results {
		results[i].{{.FieldName}} = byFK[results[i].{{.ParentPKField}}]
	}
	return nil
}
{{- else if eq .RelType "has_one"}}
func {{.PreloaderName}}(ctx context.Context, db orm.Querier, results []{{.ParentType}}) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]{{.KeyType}}, len(results))
	for i := range results {
		ids[i] = results[i].{{.ParentPKField}}
	}
	related, err := {{.TargetFactory}}(db).Scopes(scope.In("{{.ForeignKey}}", ids)).All(ctx)
	if err != nil {
		return err
	}
	byFK := make(map[{{.KeyType}}]*{{.TargetType}})
	for i := range related {
		byFK[related[i].{{.ForeignKeyField}}] = &related[i]
	}
	for i := range results {
		results[i].{{.FieldName}} = byFK[results[i].{{.ParentPKField}}]
	}
	return nil
}
{{- else if eq .RelType "many_to_many"}}
func {{.PreloaderName}}(ctx context.Context, db orm.Querier, results []{{.ParentType}}) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]{{.KeyType}}, len(results))
	for i := range results {
		ids[i] = results[i].{{.ParentPKField}}
	}
	pairs, err := orm.QueryJoinTable[{{.KeyType}}, {{.KeyType}}]( //nolint:lll
		ctx, db, "{{.JoinTable}}", "{{.ForeignKey}}", "{{.References}}", ids,
	)
	if err != nil {
		return err
	}
	targetIDs := orm.UniqueTargets(pairs)
	related, err := {{.TargetFactory}}(db).Scopes(scope.In("{{.TargetPKColumn}}", targetIDs)).All(ctx)
	if err != nil {
		return err
	}
	byPK := make(map[{{.KeyType}}]{{.TargetType}})
	for _, r := range related {
		byPK[r.ID] = r
	}
	grouped := orm.GroupBySource(pairs)
	for i := range results {
		tIDs := grouped[results[i].{{.ParentPKField}}]
		items := make([]{{.TargetType}}, 0, len(tIDs))
		for _, tid := range tIDs {
			if v, ok := byPK[tid]; ok {
				items = append(items, v)
			}
		}
		results[i].{{.FieldName}} = items
	}
	return nil
}
{{- else}}
func {{.PreloaderName}}(ctx context.Context, db orm.Querier, results []{{.ParentType}}) error {
	if len(results) == 0 {
		return nil
	}
	ids := make([]{{.KeyType}}, len(results))
	for i := range results {
		ids[i] = results[i].{{.ForeignKeyField}}
	}
	related, err := {{.TargetFactory}}(db).Scopes(scope.In("id", ids)).All(ctx)
	if err != nil {
		return err
	}
	byPK := make(map[{{.KeyType}}]*{{.TargetType}})
	for i := range related {
		byPK[related[i].ID] = &related[i]
	}
	for i := range results {
		results[i].{{.FieldName}} = byPK[results[i].{{.ForeignKeyField}}]
	}
	return nil
}
{{- end}}
{{- end}}
{{end}}`

func buildRelationData(info *StructInfo, pk *FieldInfo, typePrefix string) []relationTemplateData {
	if len(info.Relations) == 0 {
		return nil
	}

	rels := make([]relationTemplateData, 0, len(info.Relations))
	for _, rel := range info.Relations {
		targetTable := inflection.Plural(naming.CamelToSnake(rel.TargetType))
		targetFactory := naming.SnakeToCamel(targetTable)
		fkField := naming.SnakeToCamel(rel.ForeignKey)

		rd := relationTemplateData{
			FieldName:       rel.FieldName,
			ParentType:      typePrefix + info.Name,
			TargetType:      typePrefix + rel.TargetType,
			TargetFactory:   targetFactory,
			ForeignKey:      rel.ForeignKey,
			ForeignKeyField: fkField,
			RelType:         rel.RelType,
			PreloaderName:   unexportedName("preload" + info.Name + rel.FieldName),
			ParentPKField:   pk.Name,
		}

		switch rel.RelType {
		case "has_many", "has_one":
			rd.KeyType = pk.GoType
			rd.JoinTargetTable = targetTable
			rd.JoinTargetColumn = rel.ForeignKey
			rd.JoinSourceTable = info.TableName
			rd.JoinSourceColumn = pk.Column
		case "many_to_many":
			rd.KeyType = pk.GoType
			rd.JoinTable = rel.JoinTable
			rd.References = rel.References
			rd.TargetTable = targetTable
			rd.TargetPKColumn = "id" // convention
		default: // belongs_to
			rd.KeyType = lookupFieldType(info, rel.ForeignKey)
			rd.JoinTargetTable = targetTable
			rd.JoinTargetColumn = "id" // convention: target PK is "id"
			rd.JoinSourceTable = info.TableName
			rd.JoinSourceColumn = rel.ForeignKey
		}

		rels = append(rels, rd)
	}
	return rels
}

func lookupFieldType(info *StructInfo, column string) string {
	for _, f := range info.Fields {
		if f.Column == column {
			return f.GoType
		}
	}
	return "int" // fallback
}

func unexportedName(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func isIntType(goType string) bool {
	switch goType {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return true
	default:
		return false
	}
}
