package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
	"unicode"
)

// Render generates the Go source code for the given StructInfo.
// The returned bytes are formatted by gofmt.
func Render(info *StructInfo) ([]byte, error) {
	pk, err := info.PrimaryKeyField()
	if err != nil {
		return nil, err
	}

	data := templateData{
		Package:     info.Package,
		TypeName:    info.Name,
		TableName:   info.TableName,
		FactoryName: exportedName(info.TableName),
		PK:          pk,
		Fields:      info.Fields,
		ScanFunc:    unexportedName("scan" + info.Name),
		ColValFunc:  unexportedName(info.Name + "ColumnValuePairs"),
		SetPKFunc:   unexportedName("set" + info.Name + "PK"),
		ColumnsVar:  unexportedName(info.TableName + "Columns"),
	}

	data.IsIntPK = isIntType(pk.GoType)

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("execute template: %w", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("gofmt: %w", err)
	}
	return src, nil
}

type templateData struct {
	Package     string
	TypeName    string
	TableName   string
	FactoryName string
	PK          *FieldInfo
	Fields      []FieldInfo
	ScanFunc    string
	ColValFunc  string
	SetPKFunc   string
	ColumnsVar  string
	IsIntPK     bool
}

func (d templateData) NonPKFields() []FieldInfo {
	var fields []FieldInfo
	for _, f := range d.Fields {
		if !f.PrimaryKey {
			fields = append(fields, f)
		}
	}
	return fields
}

var funcMap = template.FuncMap{
	"join": strings.Join,
	"quote": func(s string) string {
		return `"` + s + `"`
	},
}

var tmpl = template.Must(template.New("gen").Funcs(funcMap).Parse(genTemplate))

const genTemplate = `// Code generated by ormgen; DO NOT EDIT.
package {{.Package}}

import (
	"database/sql"

	"github.com/mickamy/ormgen/orm"
)

// {{.FactoryName}} returns a new Query for the {{.TableName}} table.
func {{.FactoryName}}(db orm.Querier) *orm.Query[{{.TypeName}}] {
	return orm.NewQuery[{{.TypeName}}](
		db, "{{.TableName}}", {{.ColumnsVar}}, "{{.PK.Column}}",
		{{.ScanFunc}}, {{.ColValFunc}}, {{if .IsIntPK}}{{.SetPKFunc}}{{else}}nil{{end}},
	)
}

var {{.ColumnsVar}} = []string{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} }

func {{.ScanFunc}}(rows *sql.Rows) ({{.TypeName}}, error) {
	cols, _ := rows.Columns()
	var v {{.TypeName}}
	dest := make([]any, len(cols))
	for i, col := range cols {
		switch col {
		{{- range .Fields}}
		case {{quote .Column}}:
			dest[i] = &v.{{.Name}}
		{{- end}}
		default:
			dest[i] = new(any)
		}
	}
	err := rows.Scan(dest...)
	return v, err
}

func {{.ColValFunc}}(v *{{.TypeName}}, includesPK bool) ([]string, []any) {
	if includesPK {
		return []string{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} },
			[]any{ {{- range $i, $f := .Fields}}{{if $i}}, {{end}}v.{{$f.Name}}{{end -}} }
	}
	return []string{ {{- range $i, $f := .NonPKFields}}{{if $i}}, {{end}}{{quote $f.Column}}{{end -}} },
		[]any{ {{- range $i, $f := .NonPKFields}}{{if $i}}, {{end}}v.{{$f.Name}}{{end -}} }
}
{{if .IsIntPK}}
func {{.SetPKFunc}}(v *{{.TypeName}}, id int64) {
	v.{{.PK.Name}} = {{.PK.GoType}}(id)
}
{{end}}`

func exportedName(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func unexportedName(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func isIntType(goType string) bool {
	switch goType {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return true
	default:
		return false
	}
}
